class FFI::UCtags
  type ffi_library = Module & FFI::Library
  type members[T] = Array[T]
  type stack_entry[T] = [members[T], ^(members[T]) -> void]
  
  VERSION: String
  
  attr_accessor self.ffi_module: Module
  
  def self.ffi_const: (Object::name name) -> bot
  def ffi_const: (Object::name name) -> bot
  
  private def self.new: (_ToS library_name) -> instance
  def self.call: (_ToS library_name, _ToS header_path) ?{ () [self: ffi_library] -> void } -> ffi_library
  
  attr_reader library: ffi_library
  attr_reader composite_types: Hash[Symbol, Symbol | Class]
  attr_reader composite_typedefs: Hash[Symbol, Class]
  attr_reader composite_namespacing: Hash[Class, Class]
  attr_reader stack: Array[stack_entry[untyped]]
  @fields: Hash[String, String]
  def initialize: (_ToS library_name) -> void
  
  def new_construct: [T] (?int depth) ?{ (members[T]) -> void } -> void
  
  def extract_type: () -> [String, bool?]
  def find_type: (String name) -> FFI::Type
  def composite_type: (String name) -> Class
  def extract_and_process_type: () -> FFI::Type
  
  def process: (String k, String name, Hash[String, String] fields) -> void
  def struct: (Symbol superclass, String name) -> Class
  def typedef: (Symbol name) -> (FFI::Type | Class)
  
  def const_composites: () -> Array[Symbol]
  def close: () -> ffi_library
end
